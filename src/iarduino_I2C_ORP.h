//	Библиотека для работы с Trema модулем ORP-метр, I2C-flash для Arduino: https://iarduino.ru/shop/Sensory-Datchiki/orp-metr-flash-i2c.html
//  Версия: 1.0.2
//  Последнюю версию библиотеки Вы можете скачать по ссылке: https://iarduino.ru/file/578.html
//  Подробное описание функций бибилиотеки доступно по ссылке: https://wiki.iarduino.ru/page/orp-flash/
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел.
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_I2C_ORP_h																						//
#define iarduino_I2C_ORP_h																						//
																												//
#if defined(ARDUINO) && (ARDUINO >= 100)																		//
#include		<Arduino.h>																						//
#else																											//
#include		<WProgram.h>																					//
#endif																											//
																												//
#include		<iarduino_I2C_ORP_I2C.h>																		//	Подключаем файл iarduino_I2C_ORP_I2C.h - для работы с шиной I2C		(используя функции структуры iI2C)
																												//
#define			DEF_CHIP_ID_FLASH		0x3C																	//	ID линейки чипов - константа для всех чипов серии Flash (позволяет идентифицировать принадлежность чипа к серии).
#define			DEF_CHIP_ID_METRO		0xC3																	//	ID линейки чипов - константа для всех чипов серии Metro (позволяет идентифицировать принадлежность чипа к серии).
#define			DEF_MODEL_ORP			0x1B																	//	Идентификатор модели - константа.
//				Адреса регистров модуля:																		//
#define			REG_FLAGS_0				0x00																	//	Адрес регистра флагов управления для чтения.
#define			REG_BITS_0				0x01																	//	Адрес регистра битов  управления для чтения и записи.
#define			REG_FLAGS_1				0x02																	//	Адрес регистра флагов управления для чтения.
#define			REG_BITS_1				0x03																	//	Адрес регистра битов  управления для чтения и записи.
#define			REG_MODEL				0x04																	//	Адрес регистра содержащего номер типа модуля.
#define			REG_VERSION				0x05																	//	Адрес регистра содержащего версию прошивки.
#define			REG_ADDRESS				0x06																	//	Адрес регистра содержащего текущий адрес модуля на шине I2C. Если адрес указан с флагом IF-PIN-ADDRES то адрес установится (и запишется в регистр) только при наличии 1 на входе PIN_ADDRES.
#define			REG_CHIP_ID				0x07																	//	Адрес регистра содержащего ID линейки чипов «Flash». По данному ID можно определить принадлежность чипа к линейки «Flash».
#define			REG_ORP_HARDWARE_Eh		0x0C																	//	Адрес регистра содержащего известный ОВП (мВ) калибровочной жидкости для калибровки кнопкой в коде дополнения до двух (два байта).
#define			REG_ORP_SOFTWARE_Eh		0x0E																	//	Адрес регистра получающего известный ОВП (мВ) калибровочной жидкости для программной калибровки в коде дополнения до двух (два байта).
#define			REG_ORP_CALIBRATION		0x10																	//	Адрес регистра содержащего биты запуска и флаги статуса калибровки модуля.
#define			REG_ORP_K				0x11																	//	Адрес регистра содержащего поправочный коэффициент в десятитысячных долях (два байта).
#define			REG_ORP_Vin				0x13																	//	Адрес регистра содержащего измеряемое напряжение на входе датчика в десятитысячных долях В (два байта).
#define			REG_ORP_Vout			0x15																	//	Адрес регистра содержащего измеряемое напряжение на выходе усилителя в десятитысячных долях В (два байта).
#define			REG_ORP_Eh				0x17																	//	Адрес регистра содержащего ОВП (мВ) жидкости в коде дополнения до двух (два байта).
//				Позиция битов и флагов:																			//
#define			ORP_FLG_STATUS			0x80																	//	Флаг  регистра REG_ORP_CALIBRATION информирует о выполнении калибровки.
#define			ORP_FLG_RESULT			0x40																	//	Флаг  регистра REG_ORP_CALIBRATION информирует о результате калибровки.
#define			ORP_BIT_CALC			0x01																	//	Бит   регистра REG_ORP_CALIBRATION указывает модулю начать выполнение программной калибровки.
#define			ORP_CODE_CALC_SAVE		0x24																	//	Код   разрешения записи калибровочных данных.
																												//
class iarduino_I2C_ORP{																							//
	public:																										//
	/**	Конструктор класса **/																					//
		iarduino_I2C_ORP						(uint8_t address=0){											//	Конструктор класса														(Параметр: адрес модуля на шине I2C, если не указан (=0), то адрес будет определён).
													if(address>0x7F){ address>>=1; }							//	Корректируем адрес, если он указан с учётом бита RW.
							valAddrTemp			=	address;													//	Сохраняем переданный адрес модуля.
							objI2C				=	new iarduino_I2C;											//	Переопределяем указатель objI2C на объект производного класса iarduino_I2C.
		}																										//
	/**	Пользовательские функции **/																			//
		bool				begin				(void				);											//	Объявляем  функцию инициализации модуля									(Параметр:  отсутствует).
		bool				reset				(void				);											//	Объявляем  функцию перезагрузки модуля									(Параметр:  отсутствует).
		bool				changeAddress		(uint8_t			);											//	Объявляем  функцию смены адреса модуля на шине I2C						(Параметр:  новый адрес модуля).
		uint8_t				getAddress			(void				){ return valAddr; }						//	Определяем функцию возвращающую текущий адрес модуля на шине I2C		(Параметр:  отсутствует).
		uint8_t				getVersion			(void				){ return valVers; }						//	Определяем функцию возвращающую текущую версию прошивки модуля			(Параметр:  отсутствует).
		bool				getPullI2C			(void				);											//	Объявляем  функцию возвращающую флаг наличия подтяжки шины I2C			(Параметр:  отсутствует).
		bool				setPullI2C			(bool=true			);											//	Объявляем  функцию установки    подтяжки шины I2C						(Параметр:  флаг подтяжки).
		bool				setCalibration		(int16_t			);											//	Объявляем  функцию запуска      калибровки модуля						(Параметр:  ОВП от 0 до ±1600мВ).
		int8_t				getCalibration		(void				);											//	Объявляем  функцию получения    статуса калибровки модуля				(Параметр:  отсутствует).
		int16_t				getKnownEh			(void				);											//	Объявляем  функцию получения    Eh для калибровки модуля с кнопки		(Параметр:  отсутствует).
		bool				setKnownEh			(int16_t			);											//	Объявляем  функцию установки    Eh для калибровки модуля с кнопки		(Параметр:  ОВП от 0 до ±1600мВ).
		float				getK				(void				);											//	Объявляем  функцию получения    поправочного коэффициента				(Параметр:  отсутствует).
		bool				setK				(float				);											//	Объявляем  функцию установки    поправочного коэффициента				(Параметр:  коэффициент от 0 до 6,5535).
		float				getVin				(void				);											//	Объявляем  функцию получения    напряжения на входе датчика				(Параметр:  отсутствует).
		float				getVout				(void				);											//	Объявляем  функцию получения    напряжения на выходе усилителя			(Параметр:  отсутствует).
		int16_t				getEh				(void				);											//	Объявляем  функцию получения    ОВП жидкости							(Параметр:  отсутствует).
	private:																									//
	/**	Внутренние переменные **/																				//
		uint8_t				valAddrTemp			=	0;															//	Определяем переменную для хранения адреса модуля на шине I2C который был указан, но не был проверен.
		uint8_t				valAddr				=	0;															//	Определяем переменную для хранения адреса модуля на шине I2C.
		uint8_t				valVers				=	0;															//	Определяем переменную для хранения версии прошивки модуля.
		uint8_t				data[4];																			//	Объявляем  массив     для хранения получаемых/передаваемых данных.
		iarduino_I2C_BASE*	objI2C;																				//	Объявляем  указатель  на  объект полиморфного класса iarduino_I2C_BASE, но в конструкторе данного класса этому указателю будет присвоена ссылка на производный класс iarduino_I2C.
	/**	Внутренние функции **/																					//
		bool				_readBytes			(uint8_t, uint8_t				);								//	Объявляем  функцию чтения данных в  массив  data								(Параметры: номер первого регистра, количество байт).
		bool				_writeBytes			(uint8_t, uint8_t, uint8_t=0	);								//	Объявляем  функцию записи данных из массива data								(Параметры: номер первого регистра, количество байт, номер первого элемента массива data).
};																												//
																												//
#endif																											//